import { dirname, resolve } from "node:path"
import { unlink } from "node:fs/promises"

import { ensureDir, pathExists, readTextFile, writeTextFileIfChanged } from "../lib/fs.ts"

export type CursorScope = "project" | "user"

export type CursorRulesResult = {
  readonly scope: CursorScope
  readonly status: "created" | "updated" | "noop" | "removed" | "missing" | "error"
  readonly path: string
  readonly message?: string
}

const RULES_FILENAME = "hack.mdc"
const RULES_DIR = ".cursor/rules"
const MARKER_START = "# BEGIN HACK INTEGRATION"
const MARKER_END = "# END HACK INTEGRATION"

/**
 * Install or update Cursor rules for hack CLI usage.
 */
export async function installCursorRules(opts: {
  readonly scope: CursorScope
  readonly projectRoot?: string
}): Promise<CursorRulesResult> {
  const resolved = resolveCursorRulesPath(opts)
  if (!resolved.ok) {
    return {
      scope: opts.scope,
      status: "error",
      path: resolved.path ?? RULES_FILENAME,
      message: resolved.message
    }
  }

  const path = resolved.path
  const existed = await pathExists(path)
  await ensureDir(dirname(path))
  const result = await writeTextFileIfChanged(path, renderCursorRules())

  return {
    scope: opts.scope,
    status: result.changed ? (existed ? "updated" : "created") : "noop",
    path
  }
}

/**
 * Check whether Cursor rules are installed.
 */
export async function checkCursorRules(opts: {
  readonly scope: CursorScope
  readonly projectRoot?: string
}): Promise<CursorRulesResult> {
  const resolved = resolveCursorRulesPath(opts)
  if (!resolved.ok) {
    return {
      scope: opts.scope,
      status: "error",
      path: resolved.path ?? RULES_FILENAME,
      message: resolved.message
    }
  }

  const path = resolved.path
  const content = await readTextFile(path)
  if (!content) {
    return { scope: opts.scope, status: "missing", path }
  }

  if (!content.includes(MARKER_START)) {
    return {
      scope: opts.scope,
      status: "error",
      path,
      message: "Rules file exists but is missing hack integration markers."
    }
  }

  return { scope: opts.scope, status: "noop", path }
}

/**
 * Remove Cursor rules for hack CLI usage.
 */
export async function removeCursorRules(opts: {
  readonly scope: CursorScope
  readonly projectRoot?: string
}): Promise<CursorRulesResult> {
  const resolved = resolveCursorRulesPath(opts)
  if (!resolved.ok) {
    return {
      scope: opts.scope,
      status: "error",
      path: resolved.path ?? RULES_FILENAME,
      message: resolved.message
    }
  }

  const path = resolved.path
  if (!(await pathExists(path))) {
    return { scope: opts.scope, status: "missing", path }
  }

  await unlink(path)
  return { scope: opts.scope, status: "removed", path }
}

/**
 * Render the Cursor rules template for hack CLI usage.
 */
export function renderCursorRules(): string {
  const lines = [
    "# hack CLI",
    "# Auto-generated by 'hack setup cursor' - do not remove these markers",
    MARKER_START,
    "",
    "This project uses the hack CLI for local dev (docker compose + logs).",
    "Prefer the CLI when shell access is available. Use MCP only if the CLI is unavailable.",
    "",
    "## Core Rules",
    "- Use hack CLI for start/stop/open/logs/run workflows.",
    "- Use `--json` for machine-readable output when available.",
    "- Only use MCP in no-shell environments.",
    "",
    "## Quick Reference",
    "```bash",
    "hack up --detach",
    "hack open --json",
    "hack logs --pretty",
    "hack logs --json --no-follow",
    "hack run <service> <cmd...>",
    "hack down",
    "hack up --branch <name> --detach",
    "hack open --branch <name>",
    "hack logs --branch <name>",
    "hack down --branch <name>",
    "```",
    "",
    "## MCP (optional)",
    "- Install only if no shell access: `hack setup mcp`",
    "",
    MARKER_END,
    ""
  ]

  return lines.join("\n")
}

function resolveCursorRulesPath(opts: {
  readonly scope: CursorScope
  readonly projectRoot?: string
}): { readonly ok: true; readonly path: string } | { readonly ok: false; readonly message: string; readonly path?: string } {
  if (opts.scope === "project" && !opts.projectRoot) {
    return { ok: false, message: "Missing project root for project-scoped Cursor rules." }
  }

  const root = opts.scope === "user" ? resolveHomeDir() : opts.projectRoot
  if (!root) {
    return { ok: false, message: "HOME is not set; cannot resolve user rules path." }
  }

  return { ok: true, path: resolve(root, RULES_DIR, RULES_FILENAME) }
}

function resolveHomeDir(): string | null {
  const home = (process.env.HOME ?? "").trim()
  return home.length > 0 ? home : null
}
