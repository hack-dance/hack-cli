import { basename, resolve } from "node:path"
import { readdir } from "node:fs/promises"

type VariantName = "cut" | "mash"

type VariantInput = {
  readonly name: VariantName
  readonly gifPath: string
  readonly durationSeconds: number
}

type GeneratedVariant = {
  readonly name: VariantName
  readonly fps: number
  readonly framesGzipBase64: string
}

const FPS = 20
const SIZE = "120x32"

const repoRoot = resolve(import.meta.dir, "..")

async function main(): Promise<void> {
  const variants: readonly VariantInput[] = [
    { name: "cut", gifPath: resolve(repoRoot, "assets/cut.gif"), durationSeconds: 10 },
    {
      name: "mash",
      gifPath: resolve(repoRoot, "hacker-mash.gif"),
      durationSeconds: 15
    }
  ]

  const outputs: GeneratedVariant[] = []
  for (const v of variants) {
    outputs.push(await generateVariant(v))
  }

  const outFile = resolve(repoRoot, "src/ui/planet-animations.data.ts")
  await writeTextFile(outFile, renderTs(outputs))
  process.stdout.write(`Wrote ${basename(outFile)} (${outputs.length} variants)\n`)
}

async function generateVariant(input: VariantInput): Promise<GeneratedVariant> {
  const tmpDir = resolve("/tmp", `hack-planet-${input.name}`)
  await run(["rm", "-rf", tmpDir])
  await run(["mkdir", "-p", tmpDir])

  const framePattern = resolve(tmpDir, "frame-%04d.png")
  await run([
    "ffmpeg",
    "-hide_banner",
    "-loglevel",
    "error",
    "-y",
    "-i",
    input.gifPath,
    "-t",
    String(input.durationSeconds),
    "-vf",
    `fps=${FPS}`,
    framePattern
  ])

  const files = (await readdir(tmpDir))
    .filter(f => f.endsWith(".png"))
    .sort((a, b) => a.localeCompare(b))

  if (files.length === 0) {
    throw new Error(`No frames extracted for ${input.name}`)
  }

  const frames: string[] = []
  for (const file of files) {
    const framePath = resolve(tmpDir, file)
    const frame = await renderFrame(framePath)
    frames.push(frame)
  }

  const payload = JSON.stringify({ frames })
  const gz = Bun.gzipSync(new TextEncoder().encode(payload))
  const base64 = Buffer.from(gz).toString("base64")

  return { name: input.name, fps: FPS, framesGzipBase64: base64 }
}

async function renderFrame(framePath: string): Promise<string> {
  // NOTE: `--animate=off` is critical, otherwise chafa will emit an animation stream.
  const { stdout } = await runCapture([
    "chafa",
    framePath,
    "--format=symbols",
    "--animate=off",
    `--size=${SIZE}`,
    "--symbols=all",
    "--colors=8",
    "--dither=none",
    "--preprocess=off",
    "--work=1",
    "--optimize=9",
    "--relative=off"
  ])

  // Keep frames deterministic + avoid per-frame cursor flicker (player controls cursor visibility).
  return stdout.replaceAll("\x1b[?25l", "").replaceAll("\x1b[?25h", "")
}

function chunkString(input: string, size: number): string[] {
  const out: string[] = []
  for (let i = 0; i < input.length; i += size) {
    out.push(input.slice(i, i + size))
  }
  return out
}

function renderTs(variants: readonly GeneratedVariant[]): string {
  const header = [
    "// @generated by `bun scripts/generate-planet-animations.ts`",
    "// Do not edit by hand.",
    "",
    "export const PLANET_ANIMATIONS_DATA = ["
  ]

  const body = variants.flatMap(v => {
    const chunks = chunkString(v.framesGzipBase64, 120)
    return [
      "  {",
      `    name: \"${v.name}\",`,
      `    fps: ${v.fps},`,
      "    framesGzipBase64: [",
      ...chunks.map(c => `      \"${c}\",`),
      '    ].join(""),',
      "  },"
    ]
  })

  const footer = ["] as const;", ""]
  return [...header, ...body, ...footer].join("\n")
}

async function run(cmd: string[]): Promise<void> {
  const proc = Bun.spawn(cmd, {
    stdin: "ignore",
    stdout: "ignore",
    stderr: "pipe"
  })
  const stderr = await new Response(proc.stderr).text()
  const exitCode = await proc.exited
  if (exitCode !== 0) {
    throw new Error(`Command failed (${exitCode}): ${cmd.join(" ")}\n${stderr}`)
  }
}

async function runCapture(
  cmd: string[]
): Promise<{ readonly stdout: string; readonly stderr: string }> {
  const proc = Bun.spawn(cmd, {
    stdin: "ignore",
    stdout: "pipe",
    stderr: "pipe"
  })
  const stdout = await new Response(proc.stdout).text()
  const stderr = await new Response(proc.stderr).text()
  const exitCode = await proc.exited
  if (exitCode !== 0) {
    throw new Error(`Command failed (${exitCode}): ${cmd.join(" ")}\n${stderr}`)
  }
  return { stdout, stderr }
}

async function writeTextFile(path: string, content: string): Promise<void> {
  await Bun.write(path, content)
}

await main()
